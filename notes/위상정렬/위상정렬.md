## 위상 정렬 (Topological Sort)

> 위상 정렬은 **방향 그래프(DAG, Directed Acyclic Graph)** 에서 정점들을 **순서대로 나열**하는 방법이다.
> 사이클이 존재한다면 위상 정렬 불가능

---

### 위상 정렬이 가능한지 여부

- **가능 조건**: 사이클이 없는 방향 그래프(DAG)
- **사이클 발생 여부**: 위상 정렬 과정에서 모든 노드를 방문하지 못하면 사이클이 존재한다고 판단

---

## BFS (Kahn’s Algorithm) 방식

### 알고리즘 과정

1. 진입 차수(indegree)가 0인 노드를 큐에 삽입
2. 큐에서 원소를 꺼내고 결과 리스트에 추가
3. 해당 노드에서 나가는 간선을 제거 -> 도착 노드의 진입 차수 -1
4. 새롭게 진입 차수가 0이 된 노드를 큐에 삽입
5. 큐가 빌 때까지 반복
   -> 모든 노드를 방문하지 못했다면 **사이클 존재**

### Java 코드 템플릿

```java
public class TopoSortBFS {
    static int N, M;
    static List<Integer>[] graph;
    static int[] indegree;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt();
        M = sc.nextInt();

        graph = new ArrayList[N + 1];
        indegree = new int[N + 1];
        for (int i = 1; i <= N; i++) graph[i] = new ArrayList<>();

        for (int i = 0; i < M; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            graph[a].add(b);
            indegree[b]++;
        }

        List<Integer> result = topoSort();
        if (result.size() != N) {
            System.out.println("사이클 존재 → 위상정렬 불가능");
        } else {
            System.out.println(result);
        }
    }

    static List<Integer> topoSort() {
        Queue<Integer> q = new LinkedList<>();
        List<Integer> result = new ArrayList<>();

        for (int i = 1; i <= N; i++) {
            if (indegree[i] == 0) q.add(i);
        }

        while (!q.isEmpty()) {
            int cur = q.poll();
            result.add(cur);

            for (int nxt : graph[cur]) {
                indegree[nxt]--;
                if (indegree[nxt] == 0) q.add(nxt);
            }
        }
        return result;
    }
}
```

---

## DFS 방식

### 알고리즘 과정

1. 방문하지 않은 노드에 대해 DFS 수행
2. 재귀 호출이 끝날 때마다 스택에 push
3. 모든 DFS 종료 후, 스택을 pop 하면서 결과 생성
4. DFS 중 방문 중인 노드를 다시 방문하면 **사이클 존재**

### Java 코드 템플릿

```java
public class TopoSortDFS {
    static int N, M;
    static List<Integer>[] graph;
    static boolean[] visited, finished;
    static Stack<Integer> stack;
    static boolean hasCycle = false;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt();
        M = sc.nextInt();

        graph = new ArrayList[N + 1];
        for (int i = 1; i <= N; i++) graph[i] = new ArrayList<>();

        for (int i = 0; i < M; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            graph[a].add(b);
        }

        visited = new boolean[N + 1];
        finished = new boolean[N + 1];
        stack = new Stack<>();

        for (int i = 1; i <= N; i++) {
            if (!visited[i]) dfs(i);
        }

        if (hasCycle) {
            System.out.println("사이클 존재 → 위상정렬 불가능");
        } else {
            while (!stack.isEmpty()) {
                System.out.print(stack.pop() + " ");
            }
        }
    }

    static void dfs(int node) {
        visited[node] = true;

        for (int nxt : graph[node]) {
            if (!visited[nxt]) dfs(nxt);
            else if (!finished[nxt]) hasCycle = true; // 방문 중에 다시 방문 → 사이클
        }

        finished[node] = true;
        stack.push(node);
    }
}
```

---

## 정리

- **BFS (Kahn’s Algorithm)**: 큐 + 진입차수 이용

  - 직관적이고 사이클 판별이 간단

- **DFS 방식**: 재귀 호출 + 스택 이용

  - 구현은 간단하지만 사이클 판별 시 주의 필요
