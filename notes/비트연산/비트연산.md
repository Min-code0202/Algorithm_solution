## 비트연산

| 연산자 | 연산자의 기능                                                      |
| ------ | ------------------------------------------------------------------ |
| `&`    | 비트단위로 AND 연산을 한다. 예) `num1 & num2`                      |
| `\|`   | 비트단위로 OR 연산을 한다. 예) `num1 \| num2`                      |
| `^`    | 비트단위로 XOR 연산을 한다. (같으면 0, 다르면 1) 예) `num1 ^ num2` |
| `~`    | 단항 연산자로 피연산자의 모든 비트를 반전시킨다. 예) `~num`        |
| `<<`   | 피연산자의 비트 열을 왼쪽으로 이동시킨다. 예) `num << 2`           |
| `>>`   | 피연산자의 비트 열을 오른쪽으로 이동시킨다. 예) `num >> 2`         |

### 바이너리 카운팅을 이용한 부분집합

```java
int[] arr = {3, 6, 7, 1, 5, 4};
int n = arr.length;

for(int i = 0; i < (1 << n); i++){ // 1 << n : 부분집합의 개수
    for(int j = 0; j < n; j++){ // 원소의 수만큼 비트를 비교함
        if((i % (1 << j)) != 0) // i의 j번째 비트가 1이면 j번째 원소 출력
            System.out.print(arr[j] + " ");
    }
    System.out.println();
}
```

### 비트마스킹 - 순열 생성

```
perm(cnt, flag)
    if cnt == N
        순열생성완료
    else
        for i from 0 to N - 1
            if(flag & 1<<i) != 0 then continue
            numbers[cnt] <- input[i]
            perm(cnt + 1, flag | 1 << i)
        end for
end perm()
```

### 비트마스킹 - 사전 순

- 배열을 오름차순으로 정렬 후 시작
- 아래 과정 반복
  1. 뒤쪽부터 탐색하며 교환위치(i - 1) 찾기 (i: 꼭대기)
  2. 뒤쪽부터 탐색하며 교환위치(i - 1)와 교환할 큰 값 위치(j) 찾기
  3. 두 위치 값(i - 1, j) 교환
  4. 꼭대기 위치(i) 부터 맨 뒤까지 오름차순 정렬
