## 최장 증가 부분 수열 (Longest Increasing Subsequence, LIS)
> 주어진 수열에서 **순서를 유지**하면서, **값이 점진적으로 커지는 가장 긴 부분 수열**을 찾는 문제

### 예시   
수열: \[10, 20, 10, 30, 20, 50]  
LIS: \[10, 20, 30, 50] (길이 = 4)

---

## 접근 방법

### 1. Brute-force (완전 탐색)

* 수열의 **모든 부분 수열**을 구한다.
* 각 부분 수열이 **증가 수열인지 판별**한다.
* 그중 가장 긴 부분 수열의 길이를 반환한다.
* 시간 복잡도: **O(2^n)** → n이 커지면 비효율적.

---

### 2. DP (Dynamic Programming)

* **점화식**: dp\[i] = i번째 원소를 마지막으로 하는 LIS의 길이
* 초기값: dp\[i] = 1 (모든 원소는 길이 1의 LIS 가능)
* 점화식:

  ```
  for i in 1..n:
      for j in 0..i-1:
          if arr[j] < arr[i]:
              dp[i] = max(dp[i], dp[j] + 1)
  ```
* 최종 답: max(dp)
* 시간 복잡도: **O(n^2)**

**Java 예시 코드:**

```java
int n = arr.length;
int[] dp = new int[n];
Arrays.fill(dp, 1);

for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
        if (arr[j] < arr[i]) {
            dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
}

int result = Arrays.stream(dp).max().getAsInt();
System.out.println(result);
```

---

### 3. DP + 이진 탐색 활용

* **LIS 수열을 직접 관리**하면서 이진 탐색으로 최적 위치에 원소 삽입
* 각 원소마다 LIS 배열에서 **자리를 찾아 교체** → 길이는 유지, 값 최적화
* 시간 복잡도: **O(n log n)**

**접근 방식:**

1. LIS 배열 초기화
2. 각 원소 x에 대해

   * LIS 배열의 끝보다 크면 그대로 추가
   * 아니면 LIS 배열에서 x 이상인 첫 원소를 x로 교체 (이진 탐색)

**Java 예시 코드:**

```java
int n = ...;                // 수열 길이
int[] arr = ...;            // 입력 수열
int[] lis = new int[n];     // LIS 배열

// 이진 탐색 함수: target이 들어갈 위치를 찾는다.
int binarySearch(int left, int right, int target) {
    while (left < right) {
        int mid = (left + right) / 2;
        if (lis[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return right;
}

// 메인 로직
int j = 0;
lis[0] = arr[0];

for (int i = 1; i < n; i++) {
    if (lis[j] < arr[i]) {
        lis[++j] = arr[i];
    } else {
        int idx = binarySearch(0, j, arr[i]);
        lis[idx] = arr[i];
    }
}

System.out.println(j + 1);  // LIS 길이 출력
```

---

## 시간 복잡도 비교

| 방법          | 시간 복잡도     |
| ----------- | ---------- |
| Brute-force | O(2^n)     |
| DP          | O(n^2)     |
| DP + 이진 탐색  | O(n log n) |

---

## 추가 참고

* **O(n log n)** 방법은 실제 LIS 수열 값이 아니라 **길이**만 빠르게 구할 수 있음.
* 실제 수열을 복원하려면 **추적 배열**을 추가 관리해야 함.